#######################################################################
# Test for copying block of size 4;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $4, %rdx		# src and dst have 4 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
	call ncopy		 
	halt			# should halt with num nonzeros in %rax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#
# Describe how and why you modified the baseline code.
# Modified by GitHub Copilot
# 1. Used iaddq to replace constant addition/subtraction.
# 2. Implemented 10-way loop unrolling to reduce loop overhead.
# 3. Interleaved memory access to avoid load-use hazards.
# 4. Used a jump table/tree structure to handle remaining elements.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
    # Loop header
    xorq %rax,%rax		# count = 0;
    iaddq $-10, %rdx    # len -= 10
    jl Root             # if len < 10, handle remainder

Loop:
    mrmovq (%rdi), %r8      # read val 1
    mrmovq 8(%rdi), %r9     # read val 2
    mrmovq 16(%rdi), %r10   # read val 3
    mrmovq 24(%rdi), %r11   # read val 4
    mrmovq 32(%rdi), %r12   # read val 5
    mrmovq 40(%rdi), %r13   # read val 6
    mrmovq 48(%rdi), %r14   # read val 7
    mrmovq 56(%rdi), %rbx   # read val 8
    mrmovq 64(%rdi), %rcx   # read val 9
    mrmovq 72(%rdi), %rbp   # read val 10

    rmmovq %r8, (%rsi)      # store val 1
    rmmovq %r9, 8(%rsi)     # store val 2
    rmmovq %r10, 16(%rsi)   # store val 3
    rmmovq %r11, 24(%rsi)   # store val 4
    rmmovq %r12, 32(%rsi)   # store val 5
    rmmovq %r13, 40(%rsi)   # store val 6
    rmmovq %r14, 48(%rsi)   # store val 7
    rmmovq %rbx, 56(%rsi)   # store val 8
    rmmovq %rcx, 64(%rsi)   # store val 9
    rmmovq %rbp, 72(%rsi)   # store val 10

    andq %r8, %r8           # val 1 <= 0?
    jle Check2
    iaddq $1, %rax          # count++
Check2:
    andq %r9, %r9           # val 2 <= 0?
    jle Check3
    iaddq $1, %rax
Check3:
    andq %r10, %r10         # val 3 <= 0?
    jle Check4
    iaddq $1, %rax
Check4:
    andq %r11, %r11         # val 4 <= 0?
    jle Check5
    iaddq $1, %rax
Check5:
    andq %r12, %r12         # val 5 <= 0?
    jle Check6
    iaddq $1, %rax
Check6:
    andq %r13, %r13         # val 6 <= 0?
    jle Check7
    iaddq $1, %rax
Check7:
    andq %r14, %r14         # val 7 <= 0?
    jle Check8
    iaddq $1, %rax
Check8:
    andq %rbx, %rbx         # val 8 <= 0?
    jle Check9
    iaddq $1, %rax
Check9:
    andq %rcx, %rcx         # val 9 <= 0?
    jle Check10
    iaddq $1, %rax
Check10:
    andq %rbp, %rbp         # val 10 <= 0?
    jle EndLoop
    iaddq $1, %rax

EndLoop:
    iaddq $80, %rdi         # src += 10
    iaddq $80, %rsi         # dst += 10
    iaddq $-10, %rdx        # len -= 10 (loop check)
    jge Loop

Root:   # Handle remainder: len is now between -10 and -1
    iaddq $7, %rdx      # restore logic index: range now -3 to 6
    jl Left             # if < 0 (orig len 0,1,2), go Left
    jg Right            # if > 0 (orig len 4..9), go Right
    je Rem3             # if = 0 (orig len 3), do 3

Left: # Handles 0, 1, 2
    iaddq $2, %rdx      # range now -1 to 1
    je Rem1             # if = 0 (orig len 1), do 1
    jl Done             # if < 0 (orig len 0), done!
    jmp Rem2            # if > 0 (orig len 2), do 2

Right: # Handles 4..9
    iaddq $-3, %rdx     # range now -2 to 3 (orig 4,5,6 -> <0; 7 -> =0; 8,9 -> >0)
    jl RightLeft        # Handles 4, 5, 6
    jg RightRight       # Handles 8, 9
    jmp Rem7            # Handles 7

RightLeft: # Handles 4, 5, 6. Current val in rdx: -2, -1, 0
    iaddq $2, %rdx      # range now 0 to 2
    je Rem4
    iaddq $-1, %rdx
    je Rem5
    jmp Rem6

RightRight: # Handles 8, 9. Current val in rdx: 1, 2
    iaddq $-1, %rdx
    je Rem8
    jmp Rem9

# ------------------------------------------------------------------
# Jump Table Logic
# ------------------------------------------------------------------

Rem9:
    mrmovq 64(%rdi), %r10
    rmmovq %r10, 64(%rsi)
    andq %r10, %r10
    jle Rem8
    iaddq $1, %rax
Rem8:
    mrmovq 56(%rdi), %r10
    rmmovq %r10, 56(%rsi)
    andq %r10, %r10
    jle Rem7
    iaddq $1, %rax
Rem7:
    mrmovq 48(%rdi), %r10
    rmmovq %r10, 48(%rsi)
    andq %r10, %r10
    jle Rem6
    iaddq $1, %rax
Rem6:
    mrmovq 40(%rdi), %r10
    rmmovq %r10, 40(%rsi)
    andq %r10, %r10
    jle Rem5
    iaddq $1, %rax
Rem5:
    mrmovq 32(%rdi), %r10
    rmmovq %r10, 32(%rsi)
    andq %r10, %r10
    jle Rem4
    iaddq $1, %rax
Rem4:
    mrmovq 24(%rdi), %r10
    rmmovq %r10, 24(%rsi)
    andq %r10, %r10
    jle Rem3
    iaddq $1, %rax
Rem3:
    mrmovq 16(%rdi), %r10
    rmmovq %r10, 16(%rsi)
    andq %r10, %r10
    jle Rem2
    iaddq $1, %rax
Rem2:
    mrmovq 8(%rdi), %r10
    rmmovq %r10, 8(%rsi)
    andq %r10, %r10
    jle Rem1
    iaddq $1, %rax
Rem1:
    mrmovq (%rdi), %r10
    rmmovq %r10, (%rsi)
    andq %r10, %r10
    jle Done
    iaddq $1, %rax

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
    ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad -1
	.quad -2
	.quad 3
	.quad 4
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
